#!@GUILE@ \
--no-auto-compile -e main -s
!#

;; Work Planner
;; Copyright (C) 2022 James Crake-Merani
;;;
;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;FIXME: Assumes that this dir already exists.
(define items-dir "/home/jamescrake-merani/.local/share/work-planner/items.json")
(use-modules (work-planner command-line)
             (work-planner date-json)
             (ice-9 textual-ports)
             (ice-9 getopt-long)
             (ice-9 format)
             (ice-9 readline)
             (srfi srfi-1)
             (srfi srfi-19))

(define (save-items! items)
  (let ((items-json (work-items->json-string items))
        (port (open items-dir O_WRONLY)))
    (truncate-file port 0)
    (put-string port items-json)
    (close port)))

;; This is the default for when the file does not exist.
(define (create-empty-work-items-file path)
  ;; If mkdir fails because the dir already exists then this is not a problem. Ignore it.
  (let ((work-planner-dir "/home/jamescrake-merani/.local/share/work-planner")) ;FIXME: Don't just use my home directory!
    (unless (and (file-exists? work-planner-dir) (file-is-directory? work-planner-dir))
      (mkdir work-planner-dir)))
  (let ((port (open path (logior O_CREAT O_WRONLY))))
    (display "[]\n" port)
    (close port)))

(define (load-work-items)
  (if (file-exists? items-dir)
      (let* ((items-port (open items-dir O_RDONLY))
             (items-json (get-string-all items-port)))
        (close items-port)
        (json-string->work-items items-json))
      (begin
        (create-empty-work-items-file items-dir)
        (load-work-items))))

(define (complete-action to-complete items)
  (let* ((to-complete-int (string->number to-complete))
         (item-to-complete (find (lambda (i) (= (assoc-ref i "id") to-complete-int)) items)))
    (save-items!
     (work-item-replace item-to-complete (work-item-complete item-to-complete) items))) )

(define (add-action options items)
  (let* ((item-text (option-ref options 'text #f))
         (due-str (option-ref options 'due #f))
         (interactive? (option-ref options 'interactive #f)))
    (if (and (not item-text) (not interactive?))
        (format #t "You cannot create a work item without text.~%")) ;; TODO: Will not have an error return code.
    (save-items!
     (add-work-item-to-lst
      (if interactive?
          (interactive-create-work-item)
          (work-item #:text item-text
                     #:due-date (if due-str (string->date due-str "~d/~m/~Y") #f))) ;;TODO: Make a much better parser for dates.
      items))))

(define (designate-action options items designate)
  (let* ((date-str (option-ref options 'due #f)) ;;TODO: Perhaps create a seperate date field.
         (desig-date (if date-str (string->date date-str "~d/~m/~Y") (current-date)))
         (old-work-item (get-work-item items (string->number designate))))
    (save-items!
     (work-item-replace old-work-item (designate-work-item-date old-work-item desig-date) items))))

(define (purge-work-items! options items)
  (let ((no-confirm (option-ref options 'no-confirm #f))
        (new-items (purge-work-items items)))
    (if (or no-confirm (string=? (string-upcase (readline (format #f "Are you sure you want to purge ~d items? (y/N): " (- (length items) (length new-items))))) "Y"))
        (save-items! new-items)
        (format #t "No work items have been purged.~%"))))

;; FIXME: There is no error handling here.
(define (main args)
  (let* ((option-spec '((complete (value #t)
                                  (single-char #\c))
                        (add (single-char #\a))
                        (text (value #t)
                              (single-char #\t))
                        (due (value #t)
                             (single-char #\d))
                        (interactive (single-char #\i))
                        (all)
                        (purge (single-char #\p))
                        (no-confirm (single-char #\y))
                        (designate (value #t)))) ;;TODO: add more options.
         (options (getopt-long args option-spec)))
    (let ((to-complete (option-ref options 'complete #f))
          (to-add (option-ref options 'add #f))
          (show-all (option-ref options 'all #f))
          (designate (option-ref options 'designate #f))
          (purge (option-ref options 'purge #f))
          (items (load-work-items)))
      (cond (to-complete (complete-action to-complete items))
            (to-add (add-action options items))
            (designate (designate-action options items designate))
            (show-all (display (show-all-items items)))
            (purge (purge-work-items! options items))
            (else (display (summary-screen items)))))))
